/*! @dinero.js/core 2.0.0-alpha.14 (UNRELEASED 1320a09) | MIT License | Â© Sarah Dayan and contributors | https://v2.dinerojs.com */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _toArray(arr) {
  return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest();
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }
  return _arr;
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var INVALID_AMOUNT_MESSAGE = 'Amount is invalid.';
var INVALID_SCALE_MESSAGE = 'Scale is invalid.';
var INVALID_RATIOS_MESSAGE = 'Ratios are invalid.';
var UNEQUAL_SCALES_MESSAGE = 'Objects must have the same scale.';
var UNEQUAL_CURRENCIES_MESSAGE = 'Objects must have the same currency.';
var NON_DECIMAL_CURRENCY_MESSAGE = 'Currency is not decimal.';

/* eslint-disable functional/no-throw-statement, valid-jsdoc */
/**
 * Assert a condition.
 *
 * @param condition - The condition to verify.
 * @param message - The error message to throw.
 *
 * @throws If the condition isn't met.
 */
function assert(condition, message) {
  if (!condition) {
    throw new Error("[Dinero.js] ".concat(message));
  }
}

/* eslint-disable functional/no-mixed-type, functional/no-return-void, functional/no-expression-statement */

function createDinero(_ref) {
  var calculator = _ref.calculator,
    onCreate = _ref.onCreate,
    _ref$formatter = _ref.formatter,
    formatter = _ref$formatter === void 0 ? {
      toNumber: Number,
      toString: String
    } : _ref$formatter;
  return function dinero(_ref2) {
    var amount = _ref2.amount,
      _ref2$currency = _ref2.currency,
      code = _ref2$currency.code,
      base = _ref2$currency.base,
      exponent = _ref2$currency.exponent,
      _ref2$scale = _ref2.scale,
      scale = _ref2$scale === void 0 ? exponent : _ref2$scale;
    var currency = {
      code: code,
      base: base,
      exponent: exponent
    };
    onCreate === null || onCreate === void 0 ? void 0 : onCreate({
      amount: amount,
      currency: currency,
      scale: scale
    });
    return {
      calculator: calculator,
      formatter: formatter,
      create: dinero,
      toJSON: function toJSON() {
        return {
          amount: amount,
          currency: currency,
          scale: scale
        };
      }
    };
  };
}

/* eslint-disable functional/no-mixed-type */

exports.ComparisonOperator = void 0;
(function (ComparisonOperator) {
  ComparisonOperator[ComparisonOperator["LT"] = -1] = "LT";
  ComparisonOperator[ComparisonOperator["EQ"] = 0] = "EQ";
  ComparisonOperator[ComparisonOperator["GT"] = 1] = "GT";
})(exports.ComparisonOperator || (exports.ComparisonOperator = {}));

/**
 * Returns an equal function.
 *
 * @param calculator - The calculator to use.
 *
 * @returns The equal function.
 */
function equal$1(calculator) {
  return function (subject, comparator) {
    return calculator.compare(subject, comparator) === exports.ComparisonOperator.EQ;
  };
}

/**
 * Returns a lessThan function.
 *
 * @param calculator - The calculator to use.
 *
 * @returns The lessThan function.
 */
function lessThan(calculator) {
  return function (subject, comparator) {
    return calculator.compare(subject, comparator) === exports.ComparisonOperator.LT;
  };
}

function absolute(calculator) {
  var equalFn = equal$1(calculator);
  var lessThanFn = lessThan(calculator);
  var zero = calculator.zero();
  return function (input) {
    if (equalFn(input, zero)) {
      return zero;
    }
    if (lessThanFn(input, zero)) {
      var minusOne = calculator.decrement(zero);
      return calculator.multiply(minusOne, input);
    }
    return input;
  };
}

/**
 * Returns a compare function.
 *
 * @param calculator - The calculator to use.
 *
 * @returns The compare function.
 */
function compare(calculator) {
  return function (subject, comparator) {
    return calculator.compare(subject, comparator);
  };
}

function isArray(maybeArray) {
  return Array.isArray(maybeArray);
}

function computeBase(calculator) {
  return function (base) {
    if (isArray(base)) {
      return base.reduce(function (acc, curr) {
        return calculator.multiply(acc, curr);
      });
    }
    return base;
  };
}

/* eslint-disable functional/no-let, functional/no-loop-statement, functional/no-expression-statement */
function countTrailingZeros(calculator) {
  var equalFn = equal$1(calculator);
  return function (input, base) {
    var zero = calculator.zero();
    if (equalFn(zero, input)) {
      return calculator.zero();
    }
    var i = zero;
    var temp = input;
    while (equalFn(calculator.modulo(temp, base), zero)) {
      temp = calculator.integerDivide(temp, base);
      i = calculator.increment(i);
    }
    return i;
  };
}

/**
 * Returns a greaterThan function.
 *
 * @param calculator - The calculator to use.
 *
 * @returns The greaterThan function.
 */
function greaterThan(calculator) {
  return function (subject, comparator) {
    return calculator.compare(subject, comparator) === exports.ComparisonOperator.GT;
  };
}

/**
 * Returns a greaterThanOrEqual function.
 *
 * @param calculator - The calculator to use.
 *
 * @returns The greaterThanOrEqual function.
 */
function greaterThanOrEqual(calculator) {
  return function (subject, comparator) {
    return greaterThan(calculator)(subject, comparator) || equal$1(calculator)(subject, comparator);
  };
}

/* eslint-disable functional/no-let, functional/no-loop-statement, functional/immutable-data, functional/no-expression-statement */
/**
 * Returns a distribute function.
 *
 * @param calculator - The calculator to use.
 *
 * @returns The distribute function.
 */
function distribute(calculator) {
  return function (value, ratios) {
    var equalFn = equal$1(calculator);
    var greaterThanFn = greaterThan(calculator);
    var lessThanFn = lessThan(calculator);
    var greaterThanOrEqualFn = greaterThanOrEqual(calculator);
    var zero = calculator.zero();
    var one = calculator.increment(zero);
    var total = ratios.reduce(function (a, b) {
      return calculator.add(a, b);
    }, zero);
    if (equalFn(total, zero)) {
      return ratios;
    }
    var remainder = value;
    var shares = ratios.map(function (ratio) {
      var share = calculator.integerDivide(calculator.multiply(value, ratio), total) || zero;
      remainder = calculator.subtract(remainder, share);
      return share;
    });
    var isPositive = greaterThanOrEqualFn(value, zero);
    var compare = isPositive ? greaterThanFn : lessThanFn;
    var amount = isPositive ? one : calculator.decrement(zero);
    var i = 0;
    while (compare(remainder, zero)) {
      if (!equalFn(ratios[i], zero)) {
        shares[i] = calculator.add(shares[i], amount);
        remainder = calculator.subtract(remainder, amount);
      }
      i++;
    }
    return shares;
  };
}

function isScaledAmount(amount) {
  return amount === null || amount === void 0 ? void 0 : amount.hasOwnProperty('amount');
}

function getAmountAndScale(value, zero) {
  if (isScaledAmount(value)) {
    var _value$scale;
    return {
      amount: value.amount,
      scale: (_value$scale = value === null || value === void 0 ? void 0 : value.scale) !== null && _value$scale !== void 0 ? _value$scale : zero
    };
  }
  return {
    amount: value,
    scale: zero
  };
}

function getDivisors(calculator) {
  var multiply = calculator.multiply;
  return function (bases) {
    return bases.reduce(function (divisors, _, i) {
      var divisor = bases.slice(i).reduce(function (acc, curr) {
        return multiply(acc, curr);
      });
      return [].concat(_toConsumableArray(divisors), [divisor]);
    }, []);
  };
}

function isEven(calculator) {
  var equalFn = equal$1(calculator);
  var zero = calculator.zero();
  var two = calculator.increment(calculator.increment(zero));
  return function (input) {
    return equalFn(calculator.modulo(input, two), zero);
  };
}

function isHalf(calculator) {
  var equalFn = equal$1(calculator);
  var absoluteFn = absolute(calculator);
  return function (input, total) {
    var remainder = absoluteFn(calculator.modulo(input, total));
    var difference = calculator.subtract(total, remainder);
    return equalFn(difference, remainder);
  };
}

/**
 * Returns a lessThanOrEqual function.
 *
 * @param calculator - The calculator to use.
 *
 * @returns The lessThanOrEqual function.
 */
function lessThanOrEqual(calculator) {
  return function (subject, comparator) {
    return lessThan(calculator)(subject, comparator) || equal$1(calculator)(subject, comparator);
  };
}

/**
 * Returns a maximum function.
 *
 * @param calculator - The calculator to use.
 *
 * @returns The maximum function.
 */
function maximum(calculator) {
  var lessThanFn = lessThan(calculator);
  return function (values) {
    return values.reduce(function (acc, curr) {
      return lessThanFn(acc, curr) ? curr : acc;
    });
  };
}

/**
 * Returns a minimum function.
 *
 * @param calculator - The calculator to use.
 *
 * @returns The minimum function.
 */
function minimum(calculator) {
  var greaterThanFn = greaterThan(calculator);
  return function (values) {
    return values.reduce(function (acc, curr) {
      return greaterThanFn(acc, curr) ? curr : acc;
    });
  };
}

function sign(calculator) {
  var equalFn = equal$1(calculator);
  var lessThanFn = lessThan(calculator);
  var zero = calculator.zero();
  return function (input) {
    if (equalFn(input, zero)) {
      return zero;
    }
    var one = calculator.increment(zero);
    var minusOne = calculator.decrement(zero);
    return lessThanFn(input, zero) ? minusOne : one;
  };
}

function haveSameCurrency(dineroObjects) {
  var _dineroObjects = _toArray(dineroObjects),
    firstDinero = _dineroObjects[0],
    otherDineros = _dineroObjects.slice(1);
  var computeBaseFn = computeBase(firstDinero.calculator);
  var _firstDinero$toJSON = firstDinero.toJSON(),
    comparator = _firstDinero$toJSON.currency;
  var equalFn = equal$1(firstDinero.calculator);
  var comparatorBase = computeBaseFn(comparator.base);
  return otherDineros.every(function (d) {
    var _d$toJSON = d.toJSON(),
      subject = _d$toJSON.currency;
    var subjectBase = computeBaseFn(subject.base);
    return subject.code === comparator.code && equalFn(subjectBase, comparatorBase) && equalFn(subject.exponent, comparator.exponent);
  });
}

/**
 * Divide and round down.
 *
 * Rounding down happens whenever the quotient is not an integer.
 *
 * @param amount - The amount to divide.
 * @param factor - The factor to divide by.
 * @param calculator - The calculator to use.
 *
 * @returns The rounded amount.
 */
var down = function down(amount, factor, calculator) {
  var greaterThanFn = greaterThan(calculator);
  var equalFn = equal$1(calculator);
  var zero = calculator.zero();
  var isPositive = greaterThanFn(amount, zero);
  var quotient = calculator.integerDivide(amount, factor);
  var remainder = calculator.modulo(amount, factor);
  var isInteger = equalFn(remainder, zero);
  if (isPositive || isInteger) {
    return quotient;
  }
  return calculator.decrement(quotient);
};

/**
 * Divide and round towards "nearest neighbor" unless both neighbors are
 * equidistant, in which case round away from zero.
 *
 * @param amount - The amount to divide.
 * @param factor - The factor to divide by.
 * @param calculator - The calculator to use.
 *
 * @returns The rounded amount.
 */
var halfAwayFromZero = function halfAwayFromZero(amount, factor, calculator) {
  var signFn = sign(calculator);
  var isHalfFn = isHalf(calculator);
  var absoluteFn = absolute(calculator);
  if (!isHalfFn(amount, factor)) {
    return halfUp(amount, factor, calculator);
  }
  return calculator.multiply(signFn(amount), up(absoluteFn(amount), factor, calculator));
};

/**
 * Divide and round towards "nearest neighbor" unless both neighbors are
 * equidistant, in which case round down.
 *
 * Rounding down happens when:
 * - The quotient is half (e.g., -1.5, 1.5).
 * - The quotient is positive and less than half (e.g., 1.4).
 * - The quotient is negative and greater than half (e.g., -1.6).
 *
 * @param amount - The amount to divide.
 * @param factor - The factor to divide by.
 * @param calculator - The calculator to use.
 *
 * @returns The rounded amount.
 */
var halfDown = function halfDown(amount, factor, calculator) {
  var isHalfFn = isHalf(calculator);
  if (isHalfFn(amount, factor)) {
    return down(amount, factor, calculator);
  }
  return halfUp(amount, factor, calculator);
};

/**
 * Divide and round towards "nearest neighbor" unless both neighbors are
 * equidistant, in which case round to the nearest even integer.
 *
 * @param amount - The amount to divide.
 * @param factor - The factor to divide by.
 * @param calculator - The calculator to use.
 *
 * @returns The rounded amount.
 */
var halfEven = function halfEven(amount, factor, calculator) {
  var isEvenFn = isEven(calculator);
  var isHalfFn = isHalf(calculator);
  var rounded = halfUp(amount, factor, calculator);
  if (!isHalfFn(amount, factor)) {
    return rounded;
  }
  return isEvenFn(rounded) ? rounded : calculator.decrement(rounded);
};

/**
 * Divide and round towards "nearest neighbor" unless both neighbors are
 * equidistant, in which case round to the nearest odd integer.
 *
 * @param amount - The amount to divide.
 * @param factor - The factor to divide by.
 * @param calculator - The calculator to use.
 *
 * @returns The rounded amount.
 */
var halfOdd = function halfOdd(amount, factor, calculator) {
  var isEvenFn = isEven(calculator);
  var isHalfFn = isHalf(calculator);
  var rounded = halfUp(amount, factor, calculator);
  if (!isHalfFn(amount, factor)) {
    return rounded;
  }
  return isEvenFn(rounded) ? calculator.decrement(rounded) : rounded;
};

/**
 * Divide and round towards "nearest neighbor" unless both neighbors are
 * equidistant, in which case round towards zero.
 *
 * @param amount - The amount to divide.
 * @param factor - The factor to divide by.
 * @param calculator - The calculator to use.
 *
 * @returns The rounded amount.
 */
var halfTowardsZero = function halfTowardsZero(amount, factor, calculator) {
  var signFn = sign(calculator);
  var isHalfFn = isHalf(calculator);
  var absoluteFn = absolute(calculator);
  if (!isHalfFn(amount, factor)) {
    return halfUp(amount, factor, calculator);
  }
  return calculator.multiply(signFn(amount), down(absoluteFn(amount), factor, calculator));
};

/**
 * Divide and round towards "nearest neighbor" unless both neighbors are
 * equidistant, in which case round up.
 *
 * Rounding up happens when:
 * - The quotient is half (e.g., -1.5, 1.5).
 * - The quotient is positive and greater than half (e.g., 1.6).
 * - The quotient is negative and less than half (e.g., -1.4).
 *
 * @param amount - The amount to divide.
 * @param factor - The factor to divide by.
 * @param calculator - The calculator to use.
 *
 * @returns The rounded amount.
 */
var halfUp = function halfUp(amount, factor, calculator) {
  var greaterThanFn = greaterThan(calculator);
  var isHalfFn = isHalf(calculator);
  var absoluteFn = absolute(calculator);
  var zero = calculator.zero();
  var remainder = absoluteFn(calculator.modulo(amount, factor));
  var difference = calculator.subtract(factor, remainder);
  var isLessThanHalf = greaterThanFn(difference, remainder);
  var isPositive = greaterThanFn(amount, zero);
  if (isHalfFn(amount, factor) || isPositive && !isLessThanHalf || !isPositive && isLessThanHalf) {
    return up(amount, factor, calculator);
  }
  return down(amount, factor, calculator);
};

/**
 * Divide and round up.
 *
 * Rounding up happens whenever the quotient is not an integer.
 *
 * @param amount - The amount to divide.
 * @param factor - The factor to divide by.
 * @param calculator - The calculator to use.
 *
 * @returns The rounded amount.
 */
var up = function up(amount, factor, calculator) {
  var greaterThanFn = greaterThan(calculator);
  var equalFn = equal$1(calculator);
  var zero = calculator.zero();
  var isPositive = greaterThanFn(amount, zero);
  var quotient = calculator.integerDivide(amount, factor);
  var remainder = calculator.modulo(amount, factor);
  var isInteger = equalFn(remainder, zero);
  if (!isInteger && isPositive) {
    return calculator.increment(quotient);
  }
  return quotient;
};

function transformScale(calculator) {
  var greaterThanFn = greaterThan(calculator);
  var computeBaseFn = computeBase(calculator);
  return function transformScaleFn() {
    for (var _len = arguments.length, _ref = new Array(_len), _key = 0; _key < _len; _key++) {
      _ref[_key] = arguments[_key];
    }
    var dineroObject = _ref[0],
      newScale = _ref[1],
      _ref$ = _ref[2],
      divide = _ref$ === void 0 ? down : _ref$;
    var _dineroObject$toJSON = dineroObject.toJSON(),
      amount = _dineroObject$toJSON.amount,
      currency = _dineroObject$toJSON.currency,
      scale = _dineroObject$toJSON.scale;
    var isLarger = greaterThanFn(newScale, scale);
    var operation = isLarger ? calculator.multiply : divide;
    var _ref2 = isLarger ? [newScale, scale] : [scale, newScale],
      _ref3 = _slicedToArray(_ref2, 2),
      a = _ref3[0],
      b = _ref3[1];
    var base = computeBaseFn(currency.base);
    var factor = calculator.power(base, calculator.subtract(a, b));
    return dineroObject.create({
      amount: operation(amount, factor, calculator),
      currency: currency,
      scale: newScale
    });
  };
}

function normalizeScale(calculator) {
  var maximumFn = maximum(calculator);
  var convertScaleFn = transformScale(calculator);
  var equalFn = equal$1(calculator);
  return function _normalizeScale() {
    for (var _len = arguments.length, _ref = new Array(_len), _key = 0; _key < _len; _key++) {
      _ref[_key] = arguments[_key];
    }
    var dineroObjects = _ref[0];
    var highestScale = dineroObjects.reduce(function (highest, current) {
      var _current$toJSON = current.toJSON(),
        scale = _current$toJSON.scale;
      return maximumFn([highest, scale]);
    }, calculator.zero());
    return dineroObjects.map(function (d) {
      var _d$toJSON = d.toJSON(),
        scale = _d$toJSON.scale;
      return !equalFn(scale, highestScale) ? convertScaleFn(d, highestScale) : d;
    });
  };
}

function unsafeAdd(calculator) {
  return function add() {
    for (var _len = arguments.length, _ref = new Array(_len), _key = 0; _key < _len; _key++) {
      _ref[_key] = arguments[_key];
    }
    var augend = _ref[0],
      addend = _ref[1];
    var _augend$toJSON = augend.toJSON(),
      augendAmount = _augend$toJSON.amount,
      currency = _augend$toJSON.currency,
      scale = _augend$toJSON.scale;
    var _addend$toJSON = addend.toJSON(),
      addendAmount = _addend$toJSON.amount;
    var amount = calculator.add(augendAmount, addendAmount);
    return augend.create({
      amount: amount,
      currency: currency,
      scale: scale
    });
  };
}
function safeAdd(calculator) {
  var normalizeFn = normalizeScale(calculator);
  var addFn = unsafeAdd(calculator);
  return function add() {
    for (var _len2 = arguments.length, _ref2 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      _ref2[_key2] = arguments[_key2];
    }
    var augend = _ref2[0],
      addend = _ref2[1];
    var condition = haveSameCurrency([augend, addend]);
    assert(condition, UNEQUAL_CURRENCIES_MESSAGE);
    var _normalizeFn = normalizeFn([augend, addend]),
      _normalizeFn2 = _slicedToArray(_normalizeFn, 2),
      newAugend = _normalizeFn2[0],
      newAddend = _normalizeFn2[1];
    return addFn(newAugend, newAddend);
  };
}

/* eslint-disable functional/no-expression-statement */
function unsafeAllocate(calculator) {
  return function allocate() {
    for (var _len = arguments.length, _ref = new Array(_len), _key = 0; _key < _len; _key++) {
      _ref[_key] = arguments[_key];
    }
    var dineroObject = _ref[0],
      ratios = _ref[1];
    var _dineroObject$toJSON = dineroObject.toJSON(),
      amount = _dineroObject$toJSON.amount,
      currency = _dineroObject$toJSON.currency,
      scale = _dineroObject$toJSON.scale;
    var distributeFn = distribute(calculator);
    var shares = distributeFn(amount, ratios.map(function (ratio) {
      return ratio.amount;
    }));
    return shares.map(function (share) {
      return dineroObject.create({
        amount: share,
        currency: currency,
        scale: scale
      });
    });
  };
}
function safeAllocate(calculator) {
  var allocateFn = unsafeAllocate(calculator);
  var greaterThanOrEqualFn = greaterThanOrEqual(calculator);
  var greaterThanFn = greaterThan(calculator);
  var convertScaleFn = transformScale(calculator);
  var maximumFn = maximum(calculator);
  var equalFn = equal$1(calculator);
  var zero = calculator.zero();
  var ten = new Array(10).fill(null).reduce(calculator.increment, zero);
  return function allocate() {
    for (var _len2 = arguments.length, _ref2 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      _ref2[_key2] = arguments[_key2];
    }
    var dineroObject = _ref2[0],
      ratios = _ref2[1];
    var hasRatios = ratios.length > 0;
    var scaledRatios = ratios.map(function (ratio) {
      return getAmountAndScale(ratio, zero);
    });
    var highestRatioScale = hasRatios ? maximumFn(scaledRatios.map(function (_ref3) {
      var scale = _ref3.scale;
      return scale;
    })) : zero;
    var normalizedRatios = scaledRatios.map(function (_ref4) {
      var amount = _ref4.amount,
        scale = _ref4.scale;
      var factor = equalFn(scale, highestRatioScale) ? zero : calculator.subtract(highestRatioScale, scale);
      return {
        amount: calculator.multiply(amount, calculator.power(ten, factor)),
        scale: scale
      };
    });
    var hasOnlyPositiveRatios = normalizedRatios.every(function (_ref5) {
      var amount = _ref5.amount;
      return greaterThanOrEqualFn(amount, zero);
    });
    var hasOneNonZeroRatio = normalizedRatios.some(function (_ref6) {
      var amount = _ref6.amount;
      return greaterThanFn(amount, zero);
    });
    var condition = hasRatios && hasOnlyPositiveRatios && hasOneNonZeroRatio;
    assert(condition, INVALID_RATIOS_MESSAGE);
    var _dineroObject$toJSON2 = dineroObject.toJSON(),
      scale = _dineroObject$toJSON2.scale;
    var newScale = calculator.add(scale, highestRatioScale);
    return allocateFn(convertScaleFn(dineroObject, newScale), normalizedRatios);
  };
}

function unsafeCompare(calculator) {
  var compareFn = compare(calculator);
  return function compare() {
    for (var _len = arguments.length, _ref = new Array(_len), _key = 0; _key < _len; _key++) {
      _ref[_key] = arguments[_key];
    }
    var dineroObject = _ref[0],
      comparator = _ref[1];
    var dineroObjects = [dineroObject, comparator];
    var _dineroObjects$map = dineroObjects.map(function (d) {
        var _d$toJSON = d.toJSON(),
          amount = _d$toJSON.amount;
        return amount;
      }),
      _dineroObjects$map2 = _slicedToArray(_dineroObjects$map, 2),
      subjectAmount = _dineroObjects$map2[0],
      comparatorAmount = _dineroObjects$map2[1];
    return compareFn(subjectAmount, comparatorAmount);
  };
}
function safeCompare(calculator) {
  var normalizeFn = normalizeScale(calculator);
  var compareFn = unsafeCompare(calculator);
  return function compare() {
    for (var _len2 = arguments.length, _ref2 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      _ref2[_key2] = arguments[_key2];
    }
    var dineroObject = _ref2[0],
      comparator = _ref2[1];
    var condition = haveSameCurrency([dineroObject, comparator]);
    assert(condition, UNEQUAL_CURRENCIES_MESSAGE);
    var _normalizeFn = normalizeFn([dineroObject, comparator]),
      _normalizeFn2 = _slicedToArray(_normalizeFn, 2),
      subjectAmount = _normalizeFn2[0],
      comparatorAmount = _normalizeFn2[1];
    return compareFn(subjectAmount, comparatorAmount);
  };
}

function convert(calculator) {
  var convertScaleFn = transformScale(calculator);
  var maximumFn = maximum(calculator);
  var zero = calculator.zero();
  return function convertFn() {
    for (var _len = arguments.length, _ref = new Array(_len), _key = 0; _key < _len; _key++) {
      _ref[_key] = arguments[_key];
    }
    var dineroObject = _ref[0],
      newCurrency = _ref[1],
      rates = _ref[2];
    var rate = rates[newCurrency.code];
    var _dineroObject$toJSON = dineroObject.toJSON(),
      amount = _dineroObject$toJSON.amount,
      scale = _dineroObject$toJSON.scale;
    var _getAmountAndScale = getAmountAndScale(rate, zero),
      rateAmount = _getAmountAndScale.amount,
      rateScale = _getAmountAndScale.scale;
    var newScale = calculator.add(scale, rateScale);
    return convertScaleFn(dineroObject.create({
      amount: calculator.multiply(amount, rateAmount),
      currency: newCurrency,
      scale: newScale
    }), maximumFn([newScale, newCurrency.exponent]));
  };
}

function haveSameAmount(calculator) {
  var normalizeFn = normalizeScale(calculator);
  var equalFn = equal$1(calculator);
  return function _haveSameAmount() {
    for (var _len = arguments.length, _ref = new Array(_len), _key = 0; _key < _len; _key++) {
      _ref[_key] = arguments[_key];
    }
    var dineroObjects = _ref[0];
    var _normalizeFn = normalizeFn(dineroObjects),
      _normalizeFn2 = _toArray(_normalizeFn),
      firstDinero = _normalizeFn2[0],
      otherDineros = _normalizeFn2.slice(1);
    var _firstDinero$toJSON = firstDinero.toJSON(),
      comparatorAmount = _firstDinero$toJSON.amount;
    return otherDineros.every(function (d) {
      var _d$toJSON = d.toJSON(),
        subjectAmount = _d$toJSON.amount;
      return equalFn(subjectAmount, comparatorAmount);
    });
  };
}

function equal(calculator) {
  return function _equal() {
    for (var _len = arguments.length, _ref = new Array(_len), _key = 0; _key < _len; _key++) {
      _ref[_key] = arguments[_key];
    }
    var dineroObject = _ref[0],
      comparator = _ref[1];
    return haveSameAmount(calculator)([dineroObject, comparator]) && haveSameCurrency([dineroObject, comparator]);
  };
}

function unsafeGreaterThan(calculator) {
  var greaterThanFn = greaterThan(calculator);
  return function greaterThan() {
    for (var _len = arguments.length, _ref = new Array(_len), _key = 0; _key < _len; _key++) {
      _ref[_key] = arguments[_key];
    }
    var dineroObject = _ref[0],
      comparator = _ref[1];
    var dineroObjects = [dineroObject, comparator];
    var _dineroObjects$map = dineroObjects.map(function (d) {
        var _d$toJSON = d.toJSON(),
          amount = _d$toJSON.amount;
        return amount;
      }),
      _dineroObjects$map2 = _slicedToArray(_dineroObjects$map, 2),
      subjectAmount = _dineroObjects$map2[0],
      comparatorAmount = _dineroObjects$map2[1];
    return greaterThanFn(subjectAmount, comparatorAmount);
  };
}
function safeGreaterThan(calculator) {
  var normalizeFn = normalizeScale(calculator);
  var greaterThanFn = unsafeGreaterThan(calculator);
  return function greaterThan() {
    for (var _len2 = arguments.length, _ref2 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      _ref2[_key2] = arguments[_key2];
    }
    var dineroObject = _ref2[0],
      comparator = _ref2[1];
    var condition = haveSameCurrency([dineroObject, comparator]);
    assert(condition, UNEQUAL_CURRENCIES_MESSAGE);
    var _normalizeFn = normalizeFn([dineroObject, comparator]),
      _normalizeFn2 = _slicedToArray(_normalizeFn, 2),
      subjectAmount = _normalizeFn2[0],
      comparatorAmount = _normalizeFn2[1];
    return greaterThanFn(subjectAmount, comparatorAmount);
  };
}

function unsafeGreaterThanOrEqual(calculator) {
  var greaterThanOrEqualFn = greaterThanOrEqual(calculator);
  return function greaterThanOrEqual() {
    for (var _len = arguments.length, _ref = new Array(_len), _key = 0; _key < _len; _key++) {
      _ref[_key] = arguments[_key];
    }
    var dineroObject = _ref[0],
      comparator = _ref[1];
    var dineroObjects = [dineroObject, comparator];
    var _dineroObjects$map = dineroObjects.map(function (d) {
        var _d$toJSON = d.toJSON(),
          amount = _d$toJSON.amount;
        return amount;
      }),
      _dineroObjects$map2 = _slicedToArray(_dineroObjects$map, 2),
      subjectAmount = _dineroObjects$map2[0],
      comparatorAmount = _dineroObjects$map2[1];
    return greaterThanOrEqualFn(subjectAmount, comparatorAmount);
  };
}
function safeGreaterThanOrEqual(calculator) {
  var normalizeFn = normalizeScale(calculator);
  var greaterThanOrEqualFn = unsafeGreaterThanOrEqual(calculator);
  return function greaterThanOrEqual() {
    for (var _len2 = arguments.length, _ref2 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      _ref2[_key2] = arguments[_key2];
    }
    var dineroObject = _ref2[0],
      comparator = _ref2[1];
    var condition = haveSameCurrency([dineroObject, comparator]);
    assert(condition, UNEQUAL_CURRENCIES_MESSAGE);
    var _normalizeFn = normalizeFn([dineroObject, comparator]),
      _normalizeFn2 = _slicedToArray(_normalizeFn, 2),
      subjectAmount = _normalizeFn2[0],
      comparatorAmount = _normalizeFn2[1];
    return greaterThanOrEqualFn(subjectAmount, comparatorAmount);
  };
}

function hasSubUnits(calculator) {
  var equalFn = equal$1(calculator);
  var computeBaseFn = computeBase(calculator);
  return function _hasSubUnits() {
    for (var _len = arguments.length, _ref = new Array(_len), _key = 0; _key < _len; _key++) {
      _ref[_key] = arguments[_key];
    }
    var dineroObject = _ref[0];
    var _dineroObject$toJSON = dineroObject.toJSON(),
      amount = _dineroObject$toJSON.amount,
      currency = _dineroObject$toJSON.currency,
      scale = _dineroObject$toJSON.scale;
    var base = computeBaseFn(currency.base);
    return !equalFn(calculator.modulo(amount, calculator.power(base, scale)), calculator.zero());
  };
}

function isNegative(calculator) {
  var lessThanFn = lessThan(calculator);
  return function _isNegative() {
    for (var _len = arguments.length, _ref = new Array(_len), _key = 0; _key < _len; _key++) {
      _ref[_key] = arguments[_key];
    }
    var dineroObject = _ref[0];
    var _dineroObject$toJSON = dineroObject.toJSON(),
      amount = _dineroObject$toJSON.amount;
    return lessThanFn(amount, calculator.zero());
  };
}

function isPositive(calculator) {
  var greaterThanFn = greaterThan(calculator);
  return function _isPositive() {
    for (var _len = arguments.length, _ref = new Array(_len), _key = 0; _key < _len; _key++) {
      _ref[_key] = arguments[_key];
    }
    var dineroObject = _ref[0];
    var _dineroObject$toJSON = dineroObject.toJSON(),
      amount = _dineroObject$toJSON.amount;
    return greaterThanFn(amount, calculator.zero());
  };
}

function isZero(calculator) {
  var equalFn = equal$1(calculator);
  return function _isZero() {
    for (var _len = arguments.length, _ref = new Array(_len), _key = 0; _key < _len; _key++) {
      _ref[_key] = arguments[_key];
    }
    var dineroObject = _ref[0];
    var _dineroObject$toJSON = dineroObject.toJSON(),
      amount = _dineroObject$toJSON.amount;
    return equalFn(amount, calculator.zero());
  };
}

function unsafeLessThan(calculator) {
  var lessThanFn = lessThan(calculator);
  return function lessThan() {
    for (var _len = arguments.length, _ref = new Array(_len), _key = 0; _key < _len; _key++) {
      _ref[_key] = arguments[_key];
    }
    var dineroObject = _ref[0],
      comparator = _ref[1];
    var dineroObjects = [dineroObject, comparator];
    var _dineroObjects$map = dineroObjects.map(function (d) {
        var _d$toJSON = d.toJSON(),
          amount = _d$toJSON.amount;
        return amount;
      }),
      _dineroObjects$map2 = _slicedToArray(_dineroObjects$map, 2),
      subjectAmount = _dineroObjects$map2[0],
      comparatorAmount = _dineroObjects$map2[1];
    return lessThanFn(subjectAmount, comparatorAmount);
  };
}
function safeLessThan(calculator) {
  var normalizeFn = normalizeScale(calculator);
  var lessThanFn = unsafeLessThan(calculator);
  return function lessThan() {
    for (var _len2 = arguments.length, _ref2 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      _ref2[_key2] = arguments[_key2];
    }
    var dineroObject = _ref2[0],
      comparator = _ref2[1];
    var condition = haveSameCurrency([dineroObject, comparator]);
    assert(condition, UNEQUAL_CURRENCIES_MESSAGE);
    var _normalizeFn = normalizeFn([dineroObject, comparator]),
      _normalizeFn2 = _slicedToArray(_normalizeFn, 2),
      subjectAmount = _normalizeFn2[0],
      comparatorAmount = _normalizeFn2[1];
    return lessThanFn(subjectAmount, comparatorAmount);
  };
}

function unsafeLessThanOrEqual(calculator) {
  var lessThanOrEqualFn = lessThanOrEqual(calculator);
  return function lessThanOrEqual() {
    for (var _len = arguments.length, _ref = new Array(_len), _key = 0; _key < _len; _key++) {
      _ref[_key] = arguments[_key];
    }
    var dineroObject = _ref[0],
      comparator = _ref[1];
    var dineroObjects = [dineroObject, comparator];
    var _dineroObjects$map = dineroObjects.map(function (d) {
        var _d$toJSON = d.toJSON(),
          amount = _d$toJSON.amount;
        return amount;
      }),
      _dineroObjects$map2 = _slicedToArray(_dineroObjects$map, 2),
      subjectAmount = _dineroObjects$map2[0],
      comparatorAmount = _dineroObjects$map2[1];
    return lessThanOrEqualFn(subjectAmount, comparatorAmount);
  };
}
function safeLessThanOrEqual(calculator) {
  var normalizeFn = normalizeScale(calculator);
  var lessThanOrEqualFn = unsafeLessThanOrEqual(calculator);
  return function lessThanOrEqual() {
    for (var _len2 = arguments.length, _ref2 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      _ref2[_key2] = arguments[_key2];
    }
    var dineroObject = _ref2[0],
      comparator = _ref2[1];
    var condition = haveSameCurrency([dineroObject, comparator]);
    assert(condition, UNEQUAL_CURRENCIES_MESSAGE);
    var _normalizeFn = normalizeFn([dineroObject, comparator]),
      _normalizeFn2 = _slicedToArray(_normalizeFn, 2),
      subjectAmount = _normalizeFn2[0],
      comparatorAmount = _normalizeFn2[1];
    return lessThanOrEqualFn(subjectAmount, comparatorAmount);
  };
}

function unsafeMaximum(calculator) {
  var maxFn = maximum(calculator);
  return function maximum() {
    for (var _len = arguments.length, _ref = new Array(_len), _key = 0; _key < _len; _key++) {
      _ref[_key] = arguments[_key];
    }
    var dineroObjects = _ref[0];
    var _dineroObjects = _slicedToArray(dineroObjects, 1),
      firstDinero = _dineroObjects[0];
    var _firstDinero$toJSON = firstDinero.toJSON(),
      currency = _firstDinero$toJSON.currency,
      scale = _firstDinero$toJSON.scale;
    var amount = maxFn(dineroObjects.map(function (subject) {
      var _subject$toJSON = subject.toJSON(),
        subjectAmount = _subject$toJSON.amount;
      return subjectAmount;
    }));
    return firstDinero.create({
      amount: amount,
      currency: currency,
      scale: scale
    });
  };
}
function safeMaximum(calculator) {
  var normalizeFn = normalizeScale(calculator);
  var maxFn = unsafeMaximum(calculator);
  return function maximum() {
    for (var _len2 = arguments.length, _ref2 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      _ref2[_key2] = arguments[_key2];
    }
    var dineroObjects = _ref2[0];
    var condition = haveSameCurrency(dineroObjects);
    assert(condition, UNEQUAL_CURRENCIES_MESSAGE);
    var normalizedDineroObjects = normalizeFn(dineroObjects);
    return maxFn(normalizedDineroObjects);
  };
}

function unsafeMinimum(calculator) {
  var minFn = minimum(calculator);
  return function minimum() {
    for (var _len = arguments.length, _ref = new Array(_len), _key = 0; _key < _len; _key++) {
      _ref[_key] = arguments[_key];
    }
    var dineroObjects = _ref[0];
    var _dineroObjects = _slicedToArray(dineroObjects, 1),
      firstDinero = _dineroObjects[0];
    var _firstDinero$toJSON = firstDinero.toJSON(),
      currency = _firstDinero$toJSON.currency,
      scale = _firstDinero$toJSON.scale;
    var amount = minFn(dineroObjects.map(function (subject) {
      var _subject$toJSON = subject.toJSON(),
        subjectAmount = _subject$toJSON.amount;
      return subjectAmount;
    }));
    return firstDinero.create({
      amount: amount,
      currency: currency,
      scale: scale
    });
  };
}
function safeMinimum(calculator) {
  var normalizeFn = normalizeScale(calculator);
  var minFn = unsafeMinimum(calculator);
  return function maximum() {
    for (var _len2 = arguments.length, _ref2 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      _ref2[_key2] = arguments[_key2];
    }
    var dineroObjects = _ref2[0];
    var condition = haveSameCurrency(dineroObjects);
    assert(condition, UNEQUAL_CURRENCIES_MESSAGE);
    var normalizedDineroObjects = normalizeFn(dineroObjects);
    return minFn(normalizedDineroObjects);
  };
}

function multiply(calculator) {
  var convertScaleFn = transformScale(calculator);
  var zero = calculator.zero();
  return function multiplyFn() {
    for (var _len = arguments.length, _ref = new Array(_len), _key = 0; _key < _len; _key++) {
      _ref[_key] = arguments[_key];
    }
    var multiplicand = _ref[0],
      multiplier = _ref[1];
    var _multiplicand$toJSON = multiplicand.toJSON(),
      amount = _multiplicand$toJSON.amount,
      currency = _multiplicand$toJSON.currency,
      scale = _multiplicand$toJSON.scale;
    var _getAmountAndScale = getAmountAndScale(multiplier, zero),
      multiplierAmount = _getAmountAndScale.amount,
      multiplierScale = _getAmountAndScale.scale;
    var newScale = calculator.add(scale, multiplierScale);
    return convertScaleFn(multiplicand.create({
      amount: calculator.multiply(amount, multiplierAmount),
      currency: currency,
      scale: newScale
    }), newScale);
  };
}

function unsafeSubtract(calculator) {
  return function subtract() {
    for (var _len = arguments.length, _ref = new Array(_len), _key = 0; _key < _len; _key++) {
      _ref[_key] = arguments[_key];
    }
    var minuend = _ref[0],
      subtrahend = _ref[1];
    var _minuend$toJSON = minuend.toJSON(),
      minuendAmount = _minuend$toJSON.amount,
      currency = _minuend$toJSON.currency,
      scale = _minuend$toJSON.scale;
    var _subtrahend$toJSON = subtrahend.toJSON(),
      subtrahendAmount = _subtrahend$toJSON.amount;
    var amount = calculator.subtract(minuendAmount, subtrahendAmount);
    return minuend.create({
      amount: amount,
      currency: currency,
      scale: scale
    });
  };
}
function safeSubtract(calculator) {
  var normalizeFn = normalizeScale(calculator);
  var subtractFn = unsafeSubtract(calculator);
  return function subtract() {
    for (var _len2 = arguments.length, _ref2 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      _ref2[_key2] = arguments[_key2];
    }
    var minuend = _ref2[0],
      subtrahend = _ref2[1];
    var condition = haveSameCurrency([minuend, subtrahend]);
    assert(condition, UNEQUAL_CURRENCIES_MESSAGE);
    var _normalizeFn = normalizeFn([minuend, subtrahend]),
      _normalizeFn2 = _slicedToArray(_normalizeFn, 2),
      newMinuend = _normalizeFn2[0],
      newSubtrahend = _normalizeFn2[1];
    return subtractFn(newMinuend, newSubtrahend);
  };
}

function toUnits(calculator) {
  var getDivisorsFn = getDivisors(calculator);
  return function toUnitsFn() {
    for (var _len = arguments.length, _ref = new Array(_len), _key = 0; _key < _len; _key++) {
      _ref[_key] = arguments[_key];
    }
    var dineroObject = _ref[0],
      transformer = _ref[1];
    var _dineroObject$toJSON = dineroObject.toJSON(),
      amount = _dineroObject$toJSON.amount,
      currency = _dineroObject$toJSON.currency,
      scale = _dineroObject$toJSON.scale;
    var power = calculator.power,
      integerDivide = calculator.integerDivide,
      modulo = calculator.modulo;
    var bases = isArray(currency.base) ? currency.base : [currency.base];
    var divisors = getDivisorsFn(bases.map(function (base) {
      return power(base, scale);
    }));
    var value = divisors.reduce(function (amounts, divisor, index) {
      var amountLeft = amounts[index];
      var quotient = integerDivide(amountLeft, divisor);
      var remainder = modulo(amountLeft, divisor);
      return [].concat(_toConsumableArray(amounts.filter(function (_, i) {
        return i !== index;
      })), [quotient, remainder]);
    }, [amount]);
    if (!transformer) {
      return value;
    }
    return transformer({
      value: value,
      currency: currency
    });
  };
}

function toDecimal(calculator) {
  var toUnitsFn = toUnits(calculator);
  var computeBaseFn = computeBase(calculator);
  var equalFn = equal$1(calculator);
  return function toDecimalFn() {
    for (var _len = arguments.length, _ref = new Array(_len), _key = 0; _key < _len; _key++) {
      _ref[_key] = arguments[_key];
    }
    var dineroObject = _ref[0],
      transformer = _ref[1];
    var _dineroObject$toJSON = dineroObject.toJSON(),
      currency = _dineroObject$toJSON.currency,
      scale = _dineroObject$toJSON.scale;
    var base = computeBaseFn(currency.base);
    var zero = calculator.zero();
    var ten = new Array(10).fill(null).reduce(calculator.increment, zero);
    var isMultiBase = isArray(currency.base);
    var isBaseTen = equalFn(calculator.modulo(base, ten), zero);
    var isDecimal = !isMultiBase && isBaseTen;

    // eslint-disable-next-line functional/no-expression-statement
    assert(isDecimal, NON_DECIMAL_CURRENCY_MESSAGE);
    var units = toUnitsFn(dineroObject);
    var getDecimalFn = getDecimal(calculator, dineroObject.formatter);
    var value = getDecimalFn(units, scale);
    if (!transformer) {
      return value;
    }
    return transformer({
      value: value,
      currency: currency
    });
  };
}
function getDecimal(calculator, formatter) {
  var absoluteFn = absolute(calculator);
  var equalFn = equal$1(calculator);
  var lessThanFn = lessThan(calculator);
  var zero = calculator.zero();
  return function (units, scale) {
    var whole = formatter.toString(units[0]);
    var fractional = formatter.toString(absoluteFn(units[1]));
    var scaleNumber = formatter.toNumber(scale);
    var decimal = "".concat(whole, ".").concat(fractional.padStart(scaleNumber, '0'));
    var leadsWithZero = equalFn(units[0], zero);
    var isNegative = lessThanFn(units[1], zero);

    // A leading negative zero is a special case because the `toString`
    // formatter won't preserve its negative sign (since 0 === -0).
    return leadsWithZero && isNegative ? "-".concat(decimal) : decimal;
  };
}

function toSnapshot(dineroObject) {
  return dineroObject.toJSON();
}

function trimScale(calculator) {
  var countTrailingZerosFn = countTrailingZeros(calculator);
  var equalFn = equal$1(calculator);
  var maximumFn = maximum(calculator);
  var transformScaleFn = transformScale(calculator);
  var computeBaseFn = computeBase(calculator);
  return function trimScaleFn() {
    for (var _len = arguments.length, _ref = new Array(_len), _key = 0; _key < _len; _key++) {
      _ref[_key] = arguments[_key];
    }
    var dineroObject = _ref[0];
    var _dineroObject$toJSON = dineroObject.toJSON(),
      amount = _dineroObject$toJSON.amount,
      currency = _dineroObject$toJSON.currency,
      scale = _dineroObject$toJSON.scale;
    var base = computeBaseFn(currency.base);
    var trailingZerosLength = countTrailingZerosFn(amount, base);
    var difference = calculator.subtract(scale, trailingZerosLength);
    var newScale = maximumFn([difference, currency.exponent]);
    if (equalFn(newScale, scale)) {
      return dineroObject;
    }
    return transformScaleFn(dineroObject, newScale);
  };
}

exports.INVALID_AMOUNT_MESSAGE = INVALID_AMOUNT_MESSAGE;
exports.INVALID_RATIOS_MESSAGE = INVALID_RATIOS_MESSAGE;
exports.INVALID_SCALE_MESSAGE = INVALID_SCALE_MESSAGE;
exports.NON_DECIMAL_CURRENCY_MESSAGE = NON_DECIMAL_CURRENCY_MESSAGE;
exports.UNEQUAL_CURRENCIES_MESSAGE = UNEQUAL_CURRENCIES_MESSAGE;
exports.UNEQUAL_SCALES_MESSAGE = UNEQUAL_SCALES_MESSAGE;
exports.assert = assert;
exports.convert = convert;
exports.createDinero = createDinero;
exports.down = down;
exports.equal = equal;
exports.halfAwayFromZero = halfAwayFromZero;
exports.halfDown = halfDown;
exports.halfEven = halfEven;
exports.halfOdd = halfOdd;
exports.halfTowardsZero = halfTowardsZero;
exports.halfUp = halfUp;
exports.hasSubUnits = hasSubUnits;
exports.haveSameAmount = haveSameAmount;
exports.haveSameCurrency = haveSameCurrency;
exports.isNegative = isNegative;
exports.isPositive = isPositive;
exports.isZero = isZero;
exports.multiply = multiply;
exports.normalizeScale = normalizeScale;
exports.safeAdd = safeAdd;
exports.safeAllocate = safeAllocate;
exports.safeCompare = safeCompare;
exports.safeGreaterThan = safeGreaterThan;
exports.safeGreaterThanOrEqual = safeGreaterThanOrEqual;
exports.safeLessThan = safeLessThan;
exports.safeLessThanOrEqual = safeLessThanOrEqual;
exports.safeMaximum = safeMaximum;
exports.safeMinimum = safeMinimum;
exports.safeSubtract = safeSubtract;
exports.toDecimal = toDecimal;
exports.toSnapshot = toSnapshot;
exports.toUnits = toUnits;
exports.transformScale = transformScale;
exports.trimScale = trimScale;
exports.up = up;
//# sourceMappingURL=index.development.js.map
